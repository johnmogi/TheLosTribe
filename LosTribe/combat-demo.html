<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LosTribe - Combat System Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .pile-list {
            max-height: 140px;
            overflow-y: auto;
            margin-top: 8px;
            padding: 8px;
            border-radius: 6px;
            background: rgba(3, 169, 244, 0.08);
            border: 1px solid rgba(3, 169, 244, 0.2);
            font-size: 0.85em;
        }

        .pile-entry {
            padding: 2px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .dice-panel {
            margin-top: 18px;
            padding: 12px;
            border-radius: 10px;
            background: rgba(255, 215, 64, 0.08);
            border: 1px solid rgba(255, 215, 64, 0.4);
        }

        .dice-log {
            margin-top: 10px;
            font-size: 0.9em;
            line-height: 1.3;
        }

        .dice-summary {
            display: flex;
            gap: 12px;
            justify-content: space-between;
            margin-top: 10px;
        }

        .dice-column {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .dice-heading {
            font-size: 0.85em;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #ffd54f;
        }

        .dice-values {
            font-size: 1.1em;
            font-weight: bold;
            color: #ffe082;
        }

        .dice-pattern {
            font-size: 0.85em;
            color: #b0bec5;
            margin-top: 4px;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #e0e0e0;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1, h2, h3 {
            color: #64b5f6;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(100, 181, 246, 0.5);
        }

        .game-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .hero-panel, .monster-panel {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #64b5f6;
            border-radius: 10px;
            padding: 20px;
        }

        .hero-panel {
            border-color: #81c784;
        }

        .monster-panel {
            border-color: #e57373;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.08);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.8em;
            color: #bdbdbd;
        }

        .stat-value {
            font-size: 1.4em;
            font-weight: bold;
        }

        .hero-stat { color: #81c784; }
        .monster-stat { color: #e57373; }

        .hand {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
        }

        .card {
            background: rgba(100, 181, 246, 0.2);
            border: 1px solid #64b5f6;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 120px;
        }

        .card:hover {
            background: rgba(100, 181, 246, 0.3);
            transform: translateY(-2px);
        }

        .card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .card-cost {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #ffb74d;
            color: #000;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            font-weight: bold;
        }

        .combat-log {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #64b5f6;
            border-radius: 8px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.9em;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls {
            text-align: center;
            margin: 20px 0;
        }

        .controls > * {
            margin: 5px;
        }

        .controls select, .controls label {
            font-size: 0.95em;
        }

        button {
            background: #64b5f6;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            background: #42a5f5;
            transform: translateY(-2px);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .monster-list {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }

        .monster-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex-grow: 1;
        }

        .monster-hp {
            color: #e57373;
            font-weight: bold;
        }

        .monster-intent {
            background: rgba(229, 115, 115, 0.2);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
        }

        .status {
            text-align: center;
            margin: 10px 0;
            font-size: 1.2em;
            font-weight: bold;
        }

        .victory {
            color: #81c784;
        }

        .defeat {
            color: #e57373;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚öîÔ∏è LosTribe Combat System Demo</h1>

        <div class="controls">
            <button onclick="generateNewRun()">üé≠ Generate New Run</button>
            <button onclick="startCombat()" id="startBtn">‚öîÔ∏è Start Combat</button>
            <button onclick="endTurn()" id="endTurnBtn" disabled>‚è≠Ô∏è End Turn</button>
            <label for="monster-count">Monsters:</label>
            <select id="monster-count">
                <option value="1">1</option>
                <option value="2" selected>2</option>
                <option value="3">3</option>
            </select>
            <label>
                <input type="checkbox" id="show-pile-cards">
                Show pile contents
            </label>
        </div>

        <div id="status" class="status">Generate a run to begin!</div>

        <div class="game-area">
            <div class="hero-panel">
                <h2>üë§ Hero</h2>
                <div id="hero-info">
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-label">HP</div>
                            <div class="stat-value hero-stat" id="hero-hp">-</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Energy</div>
                            <div class="stat-value hero-stat" id="hero-energy">-</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Defense</div>
                            <div class="stat-value hero-stat" id="hero-defense">-</div>
                        </div>
                    </div>
                </div>

                <h3>üé¥ Hand</h3>
                <div class="hand" id="hero-hand">
                    <!-- Cards will be added here -->
                </div>

                <div class="pile-panel">
                    <div class="pile-card">
                        <div class="pile-label">Draw Pile</div>
                        <div class="pile-value" id="draw-count">0</div>
                        <div class="pile-list" id="draw-list" hidden></div>
                    </div>
                    <div class="pile-card">
                        <div class="pile-label">Discard</div>
                        <div class="pile-value" id="discard-count">0</div>
                        <div class="pile-list" id="discard-list" hidden></div>
                    </div>
                    <div class="pile-card">
                        <div class="pile-label">Exhaust</div>
                        <div class="pile-value" id="exhaust-count">0</div>
                        <div class="pile-list" id="exhaust-list" hidden></div>
                    </div>
                </div>

                <div class="dice-panel">
                    <h3>üé≤ Elemental Dice</h3>
                    <div class="dice-summary">
                        <div class="dice-column">
                            <div class="dice-heading">Hero Dice</div>
                            <div class="dice-values" id="hero-dice-values">-</div>
                            <div class="dice-pattern" id="hero-dice-pattern">Roll to begin</div>
                        </div>
                        <div class="dice-column">
                            <div class="dice-heading">Monster Dice</div>
                            <div class="dice-values" id="monster-dice-values">-</div>
                            <div class="dice-pattern" id="monster-dice-pattern">Roll to begin</div>
                        </div>
                    </div>
                    <div class="dice-pattern" id="clash-summary">Clash summary appears here.</div>
                    <div class="dice-log" id="dice-log">Rolls appear here.</div>
                </div>
            </div>

            <div class="monster-panel">
                <h2>üëπ Enemies</h2>
                <div id="monster-list" class="monster-list">
                    <!-- Monsters will be added here -->
                </div>
            </div>
        </div>

        <div>
            <h3>üìú Combat Log</h3>
            <div class="combat-log" id="combat-log">
                <!-- Log entries will be added here -->
            </div>
        </div>
    </div>

    <script type="module">
        const ELEMENTS = ['fire', 'air', 'earth', 'water'];

        class RNG {
            constructor(seed = Date.now()) {
                this.seed = seed >>> 0;
            }

            next() {
                let x = this.seed;
                x ^= x << 13;
                x ^= x >>> 17;
                x ^= x << 5;
                this.seed = x >>> 0;
                return this.seed / 0xffffffff;
            }

            pick(array) {
                return array[Math.floor(this.next() * array.length)];
            }
        }

        function roll3Elements(rng) {
            return [rng.pick(ELEMENTS), rng.pick(ELEMENTS), rng.pick(ELEMENTS)];
        }

        function tallyDice(pool) {
            return pool.reduce((acc, element) => {
                acc[element] = (acc[element] || 0) + 1;
                return acc;
            }, {});
        }

        function detectPattern(pool) {
            if (pool.length !== 3) {
                throw new Error('detectPattern expects exactly 3 dice');
            }

            const counts = tallyDice(pool);
            const unique = Object.keys(counts).length;

            if (unique === 1) {
                return { pattern: 'triple', element: pool[0], counts };
            }

            if (unique === 2) {
                const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
                return {
                    pattern: 'pair',
                    pairElement: sorted[0][0],
                    singleElement: sorted[1][0],
                    counts
                };
            }

            return { pattern: 'distinct', counts };
        }

        function checkAndConsumeDice(pool, requirement) {
            if (!requirement) return { ok: true, pool: [...pool] };
            const { element, count } = requirement;
            const available = pool.filter(die => die === element).length;
            if (available < count) return { ok: false, pool: [...pool] };

            let removed = 0;
            const remaining = [];
            for (const die of pool) {
                if (die === element && removed < count) {
                    removed += 1;
                    continue;
                }
                remaining.push(die);
            }
            return { ok: true, pool: remaining };
        }

        function hasSynergy(pool, requirement) {
            if (!requirement) return false;
            const { element, count } = requirement;
            return pool.filter(die => die === element).length >= count;
        }

        const BEATS = {
            fire: 'air',
            air: 'earth',
            earth: 'water',
            water: 'fire'
        };

        function elementMultiplier(attackerElement, defenderAffinity) {
            if (!attackerElement || attackerElement === 'neutral' || !defenderAffinity) {
                return 1.0;
            }
            if (attackerElement === defenderAffinity) return 1.0;
            if (BEATS[attackerElement] === defenderAffinity) return 1.5;
            if (BEATS[defenderAffinity] === attackerElement) return 0.5;
            return 1.0;
        }

        function patternContextFromRoll(patternResult) {
            const context = { pattern: patternResult.pattern };

            switch (patternResult.pattern) {
                case 'triple':
                    context.tripleElement = patternResult.element;
                    context.tripleBonus = 8;
                    break;
                case 'pair':
                    context.pairElement = patternResult.pairElement;
                    context.pairBonus = 4;
                    break;
                case 'distinct':
                    context.distinctBonus = 2;
                    context.energyBonus = 1;
                    break;
                default:
                    break;
            }

            return context;
        }

        function dominantElementFromPattern(patternResult, pool) {
            if (patternResult.pattern === 'triple') return patternResult.element;
            if (patternResult.pattern === 'pair') return patternResult.pairElement;
            if (patternResult.pattern === 'distinct') return null;
            return pool[0] || null;
        }

        function resolveClash(heroElement, monsterElement) {
            const outcome = {
                heroMultiplier: 1.0,
                monsterMultiplier: 1.0,
                heroShield: 0,
                monsterShield: 0,
                initiative: 'hero',
                summary: 'No dominant elements'
            };

            if (heroElement && monsterElement) {
                const heroAdvantage = elementMultiplier(heroElement, monsterElement);
                const monsterAdvantage = elementMultiplier(monsterElement, heroElement);

                if (heroAdvantage > monsterAdvantage) {
                    outcome.heroMultiplier = 1.5;
                    outcome.monsterMultiplier = 0.5;
                    outcome.heroShield = 2;
                    outcome.initiative = 'hero';
                    outcome.summary = `${heroElement.toUpperCase()} overwhelms ${monsterElement.toUpperCase()}`;
                } else if (monsterAdvantage > heroAdvantage) {
                    outcome.heroMultiplier = 0.5;
                    outcome.monsterMultiplier = 1.5;
                    outcome.monsterShield = 2;
                    outcome.initiative = 'monster';
                    outcome.summary = `${monsterElement.toUpperCase()} overwhelms ${heroElement.toUpperCase()}`;
                } else {
                    outcome.summary = `${heroElement.toUpperCase()} clashes evenly with ${monsterElement.toUpperCase()}`;
                }
            } else if (heroElement && !monsterElement) {
                outcome.heroMultiplier = 1.25;
                outcome.heroShield = 1;
                outcome.initiative = 'hero';
                outcome.summary = `Hero attunes to ${heroElement.toUpperCase()} (initiative)`;
            } else if (!heroElement && monsterElement) {
                outcome.monsterMultiplier = 1.25;
                outcome.monsterShield = 1;
                outcome.initiative = 'monster';
                outcome.summary = `Monster attunes to ${monsterElement.toUpperCase()} (initiative)`;
            }

            return outcome;
        }

        function resolveCard({
            card,
            actor,
            target,
            dicePool,
            log,
            clashMultiplier = 1.0,
            patternContext = {},
            targetShield = 0
        }) {
            const poolBeforePlay = [...dicePool];

            if (card.energyCost > actor.energy) {
                log.push(`${actor.name} lacks energy for ${card.name}`);
                return {
                    dicePool,
                    damage: 0,
                    mitigatedDamage: 0,
                    shieldRemaining: targetShield
                };
            }

            let poolAfterCost = [...dicePool];
            let costPaid = true;

            if (card.diceCost) {
                const result = checkAndConsumeDice(poolAfterCost, card.diceCost);
                if (!result.ok) {
                    costPaid = false;
                    poolAfterCost = [...dicePool];
                } else {
                    poolAfterCost = result.pool;
                }
            }

            actor.energy -= card.energyCost;

            let damage = card.baseDamage ?? 0;

            if (card.diceSynergy && hasSynergy(poolBeforePlay, card.diceSynergy.if)) {
                damage += card.diceSynergy.bonusDamage || 0;
            }

            if (patternContext.pairElement && card.element === patternContext.pairElement) {
                damage += patternContext.pairBonus || 0;
            }

            if (patternContext.tripleElement && !patternContext.tripleConsumed && card.element === patternContext.tripleElement) {
                damage += patternContext.tripleBonus || 0;
                patternContext.tripleConsumed = true;
            }

            if (patternContext.distinctBonus && !patternContext.distinctConsumed) {
                damage += patternContext.distinctBonus;
                patternContext.distinctConsumed = true;
            }

            damage = Math.floor(damage * clashMultiplier);

            const element = card.element === 'neutral' ? null : card.element;
            const elementalMultiplier = elementMultiplier(element, target.elementAffinity);
            const rawDamage = Math.max(0, Math.floor((damage - target.def) * elementalMultiplier));

            const mitigatedDamage = Math.max(0, rawDamage - targetShield);
            const shieldRemaining = Math.max(0, targetShield - rawDamage);
            target.hp = Math.max(0, target.hp - mitigatedDamage);

            if (!costPaid && card.diceCost) {
                log.push(`${actor.name} plays ${card.name} without required dice (${card.diceCost.element} x${card.diceCost.count}) ‚Üí base effect only.`);
            }

            log.push(`${actor.name} plays ${card.name} ‚Üí ${mitigatedDamage} dmg (raw ${rawDamage}, shield blocked ${rawDamage - mitigatedDamage}, clash x${clashMultiplier.toFixed(2)}, element x${elementalMultiplier.toFixed(2)})`);

            return {
                dicePool: poolAfterCost,
                damage: rawDamage,
                mitigatedDamage,
                shieldRemaining
            };
        }

        const CARD_DEFINITIONS = {
            c_strike: {
                id: 'c_strike',
                name: 'Basic Strike',
                type: 'attack',
                energyCost: 1,
                element: 'earth',
                baseDamage: 6,
                description: 'Deal 6 damage to a single foe.',
                diceSynergy: null,
                diceCost: null
            },
            c_guard: {
                id: 'c_guard',
                name: 'Stone Guard',
                type: 'defense',
                energyCost: 1,
                element: 'earth',
                block: 6,
                description: 'Gain 6 ward this turn.',
                diceSynergy: { if: { element: 'earth', count: 1 }, bonusBlock: 3 },
                diceCost: null
            },
            c_focus: {
                id: 'c_focus',
                name: 'Focus Breath',
                type: 'utility',
                energyCost: 0,
                element: 'air',
                energyGain: 1,
                description: 'Gain 1 energy.',
                diceSynergy: { if: { element: 'air', count: 1 }, bonusEnergy: 1 },
                diceCost: null
            },
            c_lantern: {
                id: 'c_lantern',
                name: 'Lantern Glow',
                type: 'utility',
                energyCost: 2,
                element: 'fire',
                heal: 8,
                description: 'Heal 8 HP.',
                diceSynergy: { if: { element: 'fire', count: 2 }, bonusHeal: 4 },
                diceCost: { element: 'fire', count: 1 }
            },
            c_cyclone: {
                id: 'c_cyclone',
                name: 'Cyclone Slash',
                type: 'attack',
                energyCost: 2,
                element: 'air',
                baseDamage: 10,
                description: 'Deal 10 damage. Pairs love the wind.',
                diceSynergy: { if: { element: 'air', count: 1 }, bonusDamage: 4 },
                diceCost: null
            }
        };

        const cardMap = new Map(Object.entries(CARD_DEFINITIONS));

        const ELEMENT_AFFINITIES = {
            m_mirage_jackal: 'air',
            m_sand_wraith: 'earth',
            m_dust_serpent: 'fire'
        };

        class ElementalCombatDemo {
            constructor() {
                this.rng = new RNG(0xC0FFEE);

                this.statusEl = document.getElementById('status');
                this.startBtn = document.getElementById('startBtn');
                this.endTurnBtn = document.getElementById('endTurnBtn');
                this.heroHpEl = document.getElementById('hero-hp');
                this.heroEnergyEl = document.getElementById('hero-energy');
                this.heroDefenseEl = document.getElementById('hero-defense');
                this.heroHandEl = document.getElementById('hero-hand');
                this.monsterListEl = document.getElementById('monster-list');
                this.combatLogEl = document.getElementById('combat-log');
                this.drawCountEl = document.getElementById('draw-count');
                this.discardCountEl = document.getElementById('discard-count');
                this.exhaustCountEl = document.getElementById('exhaust-count');
                this.drawListEl = document.getElementById('draw-list');
                this.discardListEl = document.getElementById('discard-list');
                this.exhaustListEl = document.getElementById('exhaust-list');
                this.monsterCountSelect = document.getElementById('monster-count');
                this.showPileCardsCheckbox = document.getElementById('show-pile-cards');
                this.diceLogEl = document.getElementById('dice-log');
                this.heroDiceValuesEl = document.getElementById('hero-dice-values');
                this.heroDicePatternEl = document.getElementById('hero-dice-pattern');
                this.monsterDiceValuesEl = document.getElementById('monster-dice-values');
                this.monsterDicePatternEl = document.getElementById('monster-dice-pattern');
                this.clashSummaryEl = document.getElementById('clash-summary');

                this.currentRun = null;
                this.hero = null;
                this.monsters = [];
                this.turnState = null;
                this.logEntries = [];
                this.heroHand = [];
                this.heroDrawPile = [];
                this.heroDiscardPile = [];
                this.heroExhaustPile = [];
                this.monsterCount = Number(this.monsterCountSelect.value) || 1;
            }

            init() {
                this.monsterCountSelect.addEventListener('change', (event) => {
                    this.monsterCount = Number(event.target.value) || 1;
                });

                this.showPileCardsCheckbox.addEventListener('change', () => {
                    const show = this.showPileCardsCheckbox.checked;
                    this.drawListEl.hidden = !show;
                    this.discardListEl.hidden = !show;
                    this.exhaustListEl.hidden = !show;
                    this.updatePileDisplays();
                });

                window.generateNewRun = () => this.generateNewRun();
                window.startCombat = () => this.startCombat();
                window.endTurn = () => this.endTurn();

                console.log('‚öîÔ∏è Combat System Demo ready (elemental dice mode).');
                console.log('üé≠ Click "Generate New Run" to begin.');
            }

            generateNewRun() {
                this.currentRun = this.createMockRun();
                this.statusEl.textContent = 'Run prepared. Ready for combat!';
                this.startBtn.disabled = false;
                this.endTurnBtn.disabled = true;
                this.hero = null;
                this.monsters = [];
                this.turnState = null;
                this.logEntries = [];
                this.heroHand = [];
                this.heroDrawPile = [];
                this.heroDiscardPile = [];
                this.heroExhaustPile = [];
                this.renderLog();
                this.updateOutOfCombatDisplay();
                this.clearDiceDisplay();
                this.updateHandDisplay();
                this.updatePileDisplays();
                this.renderMonsters();
            }

            startCombat() {
                if (!this.currentRun) return;
                const battleRoom = this.currentRun.dungeon.allRooms.find(room => room.type === 'battle');
                if (!battleRoom || !battleRoom.monsters || battleRoom.monsters.length === 0) {
                    this.statusEl.textContent = 'No monsters to fight!';
                    return;
                }

                this.hero = this.prepareHero(this.currentRun.hero);
                this.monsters = battleRoom.monsters
                    .slice(0, Math.max(1, Math.min(this.monsterCount, battleRoom.monsters.length)))
                    .map(monster => this.prepareMonster(monster));

                this.heroDrawPile = this.shuffle(this.hero.deck.slice());
                this.heroDiscardPile = [];
                this.heroExhaustPile = [];
                this.heroHand = this.drawCards(5);

                this.logEntries = [];
                this.log(`Combat begins in ${battleRoom.tarot} chamber!`);
                this.log(`${this.hero.name} faces ${this.monsters.length} enemies.`);

                this.statusEl.textContent = 'Combat in progress...';
                this.startBtn.disabled = true;
                this.endTurnBtn.disabled = false;

                this.beginTurn();
                this.renderAll();
            }

            endTurn() {
                if (!this.turnState) return;
                this.turnState.active = false;

                if (!this.turnState.monsterActed) {
                    this.monsterPhase();
                }

                if (this.hero && this.hero.hp <= 0) {
                    this.finishCombat('defeat');
                    this.renderAll();
                    return;
                }

                if (this.monsters.every(monster => monster.hp <= 0)) {
                    this.finishCombat('victory');
                    this.renderAll();
                    return;
                }

                this.beginTurn();
                this.renderAll();
            }

            beginTurn() {
                if (!this.hero || this.hero.hp <= 0) {
                    this.finishCombat('defeat');
                    return;
                }

                if (this.monsters.every(monster => monster.hp <= 0)) {
                    this.finishCombat('victory');
                    return;
                }

                const heroDice = roll3Elements(this.rng);
                const monsterDice = roll3Elements(this.rng);

                const heroPattern = detectPattern(heroDice);
                const monsterPattern = detectPattern(monsterDice);

                const heroPatternContext = patternContextFromRoll(heroPattern);
                const monsterPatternContext = patternContextFromRoll(monsterPattern);

                this.hero.energy = this.hero.maxEnergy + (heroPatternContext.energyBonus || 0);
                this.monsters.forEach(monster => {
                    monster.energy = monster.maxEnergy + (monsterPatternContext.energyBonus || 0);
                });

                const heroElement = dominantElementFromPattern(heroPattern, heroDice);
                const monsterElement = dominantElementFromPattern(monsterPattern, monsterDice);

                const clashOutcome = resolveClash(heroElement, monsterElement);

                this.turnState = {
                    active: true,
                    heroDiceOriginal: heroDice,
                    monsterDiceOriginal: monsterDice,
                    heroDicePool: [...heroDice],
                    monsterDicePool: [...monsterDice],
                    heroPatternContext,
                    monsterPatternContext,
                    clashOutcome,
                    heroShield: clashOutcome.heroShield || 0,
                    monsterShield: clashOutcome.monsterShield || 0,
                    heroActed: false,
                    monsterActed: false
                };

                this.log(`Hero dice ‚Üí [${heroDice.join(', ')}] (${heroPattern.pattern})`);
                this.log(`Monster dice ‚Üí [${monsterDice.join(', ')}] (${monsterPattern.pattern})`);
                this.log(`Clash: ${clashOutcome.summary}. Initiative: ${clashOutcome.initiative}.`);

                if (clashOutcome.initiative === 'monster') {
                    this.monsterPhase();
                }

                this.renderDice();
                this.renderStats();
            }

            monsterPhase() {
                if (!this.turnState || this.turnState.monsterActed) return;
                const monster = this.monsters.find(m => m.hp > 0);
                if (!monster) return;

                const dominantElement = this.turnState.monsterPatternContext.tripleElement
                    || this.turnState.monsterPatternContext.pairElement
                    || monster.intent.element
                    || monster.elementAffinity;

                const monsterCard = {
                    id: `intent_${monster.intent.type}`,
                    name: monster.intent.name,
                    energyCost: 0,
                    element: dominantElement,
                    baseDamage: monster.intent.value,
                    diceSynergy: null,
                    diceCost: null
                };

                monster.energy = monster.maxEnergy;

                const result = resolveCard({
                    card: monsterCard,
                    actor: monster,
                    target: this.hero,
                    dicePool: this.turnState.monsterDicePool,
                    log: this.logEntries,
                    clashMultiplier: this.turnState.clashOutcome.monsterMultiplier,
                    patternContext: this.turnState.monsterPatternContext,
                    targetShield: this.turnState.heroShield
                });

                this.turnState.monsterDicePool = result.dicePool;
                this.turnState.heroShield = result.shieldRemaining;
                this.turnState.monsterActed = true;
                this.turnState.active = false;

                if (this.hero.hp <= 0) {
                    this.finishCombat('defeat');
                }
            }

            playHeroCard(card, handIndex) {
                if (!this.turnState || !this.turnState.active) return;
                if (this.hero.energy < card.energyCost) {
                    this.log(`${this.hero.name} lacks energy for ${card.name}.`);
                    this.renderAll();
                    return;
                }

                let resolved = false;

                if (card.type === 'attack') {
                    const target = this.monsters.find(m => m.hp > 0);
                    if (!target) {
                        this.log('No targets remain.');
                    } else {
                        const result = resolveCard({
                            card,
                            actor: this.hero,
                            target,
                            dicePool: this.turnState.heroDicePool,
                            log: this.logEntries,
                            clashMultiplier: this.turnState.clashOutcome.heroMultiplier,
                            patternContext: this.turnState.heroPatternContext,
                            targetShield: this.turnState.monsterShield
                        });
                        this.turnState.heroDicePool = result.dicePool;
                        this.turnState.monsterShield = result.shieldRemaining;
                        resolved = true;
                        if (target.hp <= 0) {
                            this.log(`${target.name} is defeated!`);
                        }
                    }
                } else if (card.type === 'defense') {
                    let block = card.block || 0;
                    if (card.diceSynergy && this.turnState.heroDicePool.filter(e => e === card.diceSynergy.if.element).length >= card.diceSynergy.if.count) {
                        block += card.diceSynergy.bonusBlock || 0;
                    }
                    this.hero.energy -= card.energyCost;
                    this.turnState.heroShield += block;
                    this.log(`${this.hero.name} raises a ward for ${block} damage.`);
                    resolved = true;
                } else if (card.type === 'utility') {
                    this.hero.energy -= card.energyCost;
                    if (card.energyGain) {
                        let bonus = 0;
                        if (card.diceSynergy && this.turnState.heroDicePool.filter(e => e === card.diceSynergy.if.element).length >= card.diceSynergy.if.count) {
                            bonus = card.diceSynergy.bonusEnergy || 0;
                        }
                        const gain = card.energyGain + bonus;
                        this.hero.energy = Math.min(this.hero.maxEnergy, this.hero.energy + gain);
                        this.log(`${this.hero.name} gains ${gain} energy.`);
                    }
                    if (card.heal) {
                        let bonusHeal = 0;
                        if (card.diceSynergy && this.turnState.heroDicePool.filter(e => e === card.diceSynergy.if.element).length >= card.diceSynergy.if.count) {
                            bonusHeal = card.diceSynergy.bonusHeal || 0;
                        }
                        const healAmount = card.heal + bonusHeal;
                        this.hero.hp = Math.min(this.hero.maxHp, this.hero.hp + healAmount);
                        this.log(`${this.hero.name} heals ${healAmount} HP.`);
                    }
                    resolved = true;
                }

                if (resolved) {
                    if (card.type === 'attack') {
                        // resolveCard already spent energy
                    }
                    if (handIndex >= 0) {
                        const [used] = this.heroHand.splice(handIndex, 1);
                        if (used) {
                            this.heroDiscardPile.push(used.id);
                        }
                    }
                    this.turnState.heroActed = true;
                    this.fillHand();
                    if (this.monsters.every(m => m.hp <= 0)) {
                        this.finishCombat('victory');
                    }
                }

                this.renderAll();
            }

            finishCombat(result) {
                if (!result) {
                    result = this.monsters.every(m => m.hp <= 0) ? 'victory' : this.hero && this.hero.hp <= 0 ? 'defeat' : 'unknown';
                }

                this.turnState = null;
                this.startBtn.disabled = false;
                this.endTurnBtn.disabled = true;
                this.statusEl.textContent = result === 'victory' ? 'Victory! Combat completed.' : 'Defeat! Hero has fallen.';
                this.log(result === 'victory' ? 'Victory! The enemies fall.' : 'Defeat... The hero collapses.');
            }

            renderAll() {
                this.renderStats();
                this.renderDice();
                this.renderMonsters();
                this.renderLog();
                this.updateHandDisplay();
                this.updatePileDisplays();
            }

            renderStats() {
                if (!this.hero) {
                    this.heroHpEl.textContent = '-';
                    this.heroEnergyEl.textContent = '-';
                    this.heroDefenseEl.textContent = '-';
                    return;
                }

                this.heroHpEl.textContent = `${this.hero.hp}/${this.hero.maxHp}`;
                this.heroEnergyEl.textContent = `${this.hero.energy}/${this.hero.maxEnergy}`;
                const wardText = this.turnState ? ` (+${this.turnState.heroShield} ward)` : '';
                this.heroDefenseEl.textContent = `${this.hero.def}${wardText}`;
            }

            renderMonsters() {
                this.monsterListEl.innerHTML = '';
                if (!this.monsters || this.monsters.length === 0) return;

                const ward = this.turnState ? this.turnState.monsterShield : 0;
                this.monsters.forEach(monster => {
                    const el = document.createElement('div');
                    el.className = 'monster-item';
                    const intentText = monster.hp > 0 ? `${monster.intent.name} (${monster.intent.element})` : 'Defeated';
                    el.innerHTML = `
                        <div class="monster-info">
                            <strong>${monster.name}</strong><br>
                            <span class="monster-hp">HP: ${monster.hp}/${monster.maxHp}</span><br>
                            <span class="monster-hp">Ward: ${ward}</span>
                        </div>
                        <div class="monster-intent">${intentText}</div>
                    `;
                    this.monsterListEl.appendChild(el);
                });
            }

            renderLog() {
                this.combatLogEl.innerHTML = '';
                const recent = this.logEntries.slice(-14);
                recent.forEach(entry => {
                    const div = document.createElement('div');
                    div.className = 'log-entry';
                    div.textContent = entry;
                    this.combatLogEl.appendChild(div);
                });
                this.combatLogEl.scrollTop = this.combatLogEl.scrollHeight;
            }

            renderDice() {
                if (!this.turnState) {
                    this.clearDiceDisplay();
                    return;
                }

                this.heroDiceValuesEl.textContent = `[${this.turnState.heroDiceOriginal.join(', ')}]`;
                this.monsterDiceValuesEl.textContent = `[${this.turnState.monsterDiceOriginal.join(', ')}]`;

                this.heroDicePatternEl.textContent = this.describePattern(this.turnState.heroPatternContext);
                this.monsterDicePatternEl.textContent = this.describePattern(this.turnState.monsterPatternContext);

                const shieldInfo = `Hero ward ${this.turnState.heroShield} ‚Ä¢ Monster ward ${this.turnState.monsterShield}`;
                this.clashSummaryEl.textContent = `${this.turnState.clashOutcome.summary} | ${shieldInfo}`;
                this.diceLogEl.textContent = `Initiative: ${this.turnState.clashOutcome.initiative.toUpperCase()} ‚Ä¢ Multipliers H ${this.turnState.clashOutcome.heroMultiplier.toFixed(2)} / M ${this.turnState.clashOutcome.monsterMultiplier.toFixed(2)}`;
            }

            describePattern(context) {
                if (!context) return 'No roll';
                switch (context.pattern) {
                    case 'triple':
                        return `Triple ${context.tripleElement?.toUpperCase() || '?'} (+${context.tripleBonus || 0})`;
                    case 'pair':
                        return `Pair of ${context.pairElement?.toUpperCase() || '?'} (+${context.pairBonus || 0})`;
                    case 'distinct':
                        return 'All distinct (+1 energy)';
                    default:
                        return `${context.pattern}`;
                }
            }

            clearDiceDisplay() {
                this.heroDiceValuesEl.textContent = '-';
                this.heroDicePatternEl.textContent = 'Roll to begin';
                this.monsterDiceValuesEl.textContent = '-';
                this.monsterDicePatternEl.textContent = 'Roll to begin';
                this.clashSummaryEl.textContent = 'Clash summary appears here.';
                this.diceLogEl.textContent = 'Rolls appear here.';
            }

            updateHandDisplay() {
                this.heroHandEl.innerHTML = '';
                if (!this.heroHand || this.heroHand.length === 0) return;

                this.heroHand.forEach((card, index) => {
                    const cardCost = card.energyCost ?? card.cost ?? 0;
                    const disabled = !this.turnState || !this.turnState.active || this.hero.energy < cardCost;
                    const cardEl = document.createElement('div');
                    cardEl.className = `card ${disabled ? 'disabled' : ''}`;
                    cardEl.innerHTML = `
                        <div class="card-cost">${cardCost}</div>
                        <strong>${card.name}</strong><br>
                        <small>${card.description || ''}</small><br>
                        <small>Type: ${card.type}</small>
                    `;
                    if (!disabled) {
                        cardEl.onclick = () => this.playHeroCard(card, index);
                    }
                    this.heroHandEl.appendChild(cardEl);
                });
            }

            updatePileDisplays() {
                this.drawCountEl.textContent = this.heroDrawPile.length;
                this.discardCountEl.textContent = this.heroDiscardPile.length;
                this.exhaustCountEl.textContent = this.heroExhaustPile.length;

                if (!this.showPileCardsCheckbox.checked) return;

                const drawCards = this.heroDrawPile.map(id => this.resolveCardId(id)).filter(Boolean);
                const discardCards = this.heroDiscardPile.map(id => this.resolveCardId(id)).filter(Boolean);
                const exhaustCards = this.heroExhaustPile.map(id => this.resolveCardId(id)).filter(Boolean);

                this.renderPileList(this.drawListEl, drawCards, true);
                this.renderPileList(this.discardListEl, discardCards, false);
                this.renderPileList(this.exhaustListEl, exhaustCards, false);
            }

            renderPileList(container, cards, reverse = false) {
                container.innerHTML = '';
                const entries = reverse ? [...cards].reverse() : cards;
                if (entries.length === 0) {
                    container.innerHTML = '<div class="pile-entry">Empty</div>';
                    return;
                }
                entries.forEach(card => {
                    const row = document.createElement('div');
                    row.className = 'pile-entry';
                    row.textContent = `${card.name} (cost ${card.energyCost})`;
                    container.appendChild(row);
                });
            }

            log(message) {
                this.logEntries.push(message);
            }

            drawCards(count = 1) {
                const cards = [];
                for (let i = 0; i < count; i += 1) {
                    if (this.heroDrawPile.length === 0) {
                        if (this.heroDiscardPile.length === 0) break;
                        this.heroDrawPile = this.shuffle(this.heroDiscardPile.slice());
                        this.heroDiscardPile = [];
                    }
                    const id = this.heroDrawPile.shift();
                    const card = this.resolveCardId(id);
                    if (card) cards.push({ ...card });
                }
                return cards;
            }

            fillHand() {
                while (this.heroHand.length < 5) {
                    const drawn = this.drawCards(1);
                    if (drawn.length === 0) break;
                    this.heroHand.push(...drawn);
                }
            }

            resolveCardId(id) {
                const base = cardMap.get(id);
                return base ? { ...base } : null;
            }

            updateOutOfCombatDisplay() {
                if (!this.currentRun) return;
                const hero = this.currentRun.hero;
                this.heroHpEl.textContent = `${hero.stats.hp}/${hero.maxStats.hp}`;
                this.heroEnergyEl.textContent = `${hero.energy}/${hero.maxEnergy}`;
                this.heroDefenseEl.textContent = hero.stats.def;
            }

            createMockRun() {
                const heroBaseStats = { hp: 45, def: 2, maxEnergy: 3 };
                const hero = {
                    id: 'h_nomad',
                    name: 'Nomad Windwalker',
                    stats: { hp: heroBaseStats.hp, def: heroBaseStats.def },
                    maxStats: { hp: heroBaseStats.hp, def: heroBaseStats.def },
                    energy: heroBaseStats.maxEnergy,
                    maxEnergy: heroBaseStats.maxEnergy,
                    deck: [
                        'c_strike', 'c_strike', 'c_strike',
                        'c_guard', 'c_guard',
                        'c_focus', 'c_cyclone', 'c_lantern'
                    ]
                };

                const monsters = [
                    {
                        id: 'm_mirage_jackal',
                        name: 'Mirage Jackal',
                        stats: { hp: 28, atk: 7, def: 1 },
                        intent: { type: 'attack', element: 'air', value: 8, name: 'Gust Swipe' }
                    },
                    {
                        id: 'm_sand_wraith',
                        name: 'Sand Wraith',
                        stats: { hp: 24, atk: 6, def: 2 },
                        intent: { type: 'attack', element: 'earth', value: 7, name: 'Burrow Crush' }
                    },
                    {
                        id: 'm_dust_serpent',
                        name: 'Dust Serpent',
                        stats: { hp: 26, atk: 6, def: 1 },
                        intent: { type: 'attack', element: 'fire', value: 9, name: 'Pyre Lash' }
                    }
                ];

                return {
                    hero,
                    dungeon: {
                        allRooms: [
                            {
                                id: 'mock_battle_room',
                                type: 'battle',
                                tarot: 'The Magician',
                                monsters
                            }
                        ]
                    }
                };
            }

            prepareHero(hero) {
                return {
                    name: hero.name || 'Hero',
                    hp: hero.stats.hp,
                    maxHp: hero.stats.hp,
                    def: hero.stats.def,
                    energy: hero.maxEnergy,
                    maxEnergy: hero.maxEnergy,
                    elementAffinity: 'earth',
                    deck: Array.isArray(hero.deck) ? hero.deck.slice() : []
                };
            }

            prepareMonster(monster) {
                return {
                    id: monster.id,
                    name: monster.name,
                    hp: monster.stats.hp,
                    maxHp: monster.stats.hp,
                    def: monster.stats.def || 0,
                    atk: monster.stats.atk || 0,
                    elementAffinity: ELEMENT_AFFINITIES[monster.id] || 'air',
                    maxEnergy: 2,
                    energy: 2,
                    intent: { ...monster.intent }
                };
            }

            shuffle(array) {
                const copy = array.slice();
                for (let i = copy.length - 1; i > 0; i -= 1) {
                    const j = Math.floor(this.rng.next() * (i + 1));
                    [copy[i], copy[j]] = [copy[j], copy[i]];
                }
                return copy;
            }
        }

        const demo = new ElementalCombatDemo();
        demo.init();
    </script>
</body>
</html>
